#include "../PtExploitDetector/stdafx.h"
#include "../PtExploitDetector/PtExploitDetector.h"
#include "../PtExploitDetector/pt_dump.h"
#include "PtExploitDetectorGUI.h"
#include <QCoreApplication>
#include <QtWidgets/qFileDialog>

// Global app data
GLOBAL_DATA g_appData;

PtExploitDetectorGUI::PtExploitDetectorGUI(QWidget *parent)
    : QMainWindow(parent)
{
    cmdlineInput = "";
    ui.setupUi(this);
    ui.statusBar->showMessage("");
    connect(ui.buttonOpen, &QPushButton::released, this, &PtExploitDetectorGUI::openExeToTrace);
    connect(ui.buttonAnalyze, &QPushButton::released, this, &PtExploitDetectorGUI::startTrace);
    connect(ui.buttonDump, &QPushButton::released, this, &PtExploitDetectorGUI::dumpTrace);
    plog::init(plog::verbose, "PtExploitDetector.log", 1000000, 5);
}

void PtExploitDetectorGUI::openExeToTrace()
{
    // First we configure the UI aspect
    ui.filePathPanel->clear();
    ui.filePathPanel->setReadOnly(false);
    ui.labelTitle->setText(QApplication::translate("PtExploitDetectorGUIClass", "PTEXPLOITDETECTOR", nullptr));
    ui.labelTitle->setStyleSheet(QLatin1String("QLabel {\n"
        "	font: 16pt \"Open Sans\";\n"
        "	qproperty-alignment: 'AlignVCenter | AlignHCenter';\n"
        "	color: #bdc3c7;\n"
        "	background-color : #34495e;\n"
        "}"));
    
    // Now we are ready to open the dialog and chose the file
    cmdlineInput = QFileDialog::getOpenFileName(this, tr("Open File"), "C://",
        "Executable (*.exe);;Binary Trace (*.bin)");

    ui.filePathPanel->setText(cmdlineInput);
}

void PtExploitDetectorGUI::startTrace()
{
    // First we configure the UI aspect
    ui.filePathPanel->setReadOnly(true);
    
    // Now we can parse the text and start the trace
    cmdlineInput = ui.filePathPanel->text();
    if (cmdlineInput != "")
    {
        int argc = 0;
        LPWSTR* argv = CommandLineToArgvW(cmdlineInput.toStdWString().c_str(), &argc);

        std::wstring executableTarget = argv[0];
        std::wstring parameters = L"";

        if (argc > 1)
        {
            parameters = argv[0];
            for (unsigned i = 1; i < argc; ++i)
            {
                parameters.append(L" ");
                parameters.append(argv[i]);
            }
        }

        if (executableTarget.empty() || !IsExecutable(executableTarget))
        {
            ui.statusBar->showMessage("Not valid executable");
        }
        else // all was ok... lets configure the trace
        {
            ui.labelTitle->setText("ANALYZING");
            ui.labelTitle->setStyleSheet(QLatin1String("QLabel {\n"
                "	font: 16pt \"Open Sans\";\n"
                "	qproperty-alignment: 'AlignVCenter | AlignHCenter';\n"
                "	color: #34495e;\n"
                "	background-color : #27ae60;\n"
                "}"));
            g_appData.exploitDetected = FALSE;
            
            BOOL errorCode = ConfigureTrace(executableTarget, parameters);
            if (errorCode == ERROR_SUCCESS)
            {
                if (g_appData.exploitDetected)
                {
                    ui.labelTitle->setText("EXPLOIT DETECTED");
                    ui.labelTitle->setStyleSheet(QLatin1String("QLabel {\n"
                        "	font: 16pt \"Open Sans\";\n"
                        "	qproperty-alignment: 'AlignVCenter | AlignHCenter';\n"
                        "	color: #2c3e50;\n"
                        "	background-color : #e74c3c;\n"
                        "}"));

                    std::wstringstream wssChain;
                    for (unsigned index = 0; index < g_appData.chain.size(); ++index)
                    {
                        wssChain << std::hex << g_appData.chain[index].second;
                        if (g_appData.remoteAPIs.find(g_appData.chain[index].second) != g_appData.remoteAPIs.end())
                            wssChain << L" --> " << g_appData.remoteAPIs.find(g_appData.chain[index].second)->second;
                        wssChain << std::endl;

                        if (((index+1) < g_appData.chain.size()) && (g_appData.chain[index].second == g_appData.chain[index + 1].second)) ++index;
                    }

                    ui.exploitDataPanel->appendPlainText(QString::fromWCharArray(wssChain.str().c_str()));
                }
                ui.statusBar->showMessage("Done");
            }
            else
                ui.statusBar->showMessage("ERROR! Check in log file");

            if (!g_appData.exploitDetected)
            {
                ui.labelTitle->setText(QApplication::translate("PtExploitDetectorGUIClass", "PTEXPLOITDETECTOR", nullptr));
                ui.labelTitle->setStyleSheet(QLatin1String("QLabel {\n"
                    "	font: 16pt \"Open Sans\";\n"
                    "	qproperty-alignment: 'AlignVCenter | AlignHCenter';\n"
                    "	color: #bdc3c7;\n"
                    "	background-color : #34495e;\n"
                    "}"));
            }
        }
    }
    else
    {
        ui.statusBar->showMessage("ERROR! Select an executable");
    }

    ui.filePathPanel->setReadOnly(false);
}

void PtExploitDetectorGUI::dumpTrace()
{
    // First we configure the UI aspect
    ui.filePathPanel->setReadOnly(true);

    ui.labelTitle->setText("DUMPING");
    ui.labelTitle->setStyleSheet(QLatin1String("QLabel {\n"
        "	font: 16pt \"Open Sans\";\n"
        "	qproperty-alignment: 'AlignVCenter | AlignHCenter';\n"
        "	color: #bdc3c7;\n"
        "	background-color : #34495e;\n"
        "}"));

    // Now we are ready to dump the binary trace
    cmdlineInput = ui.filePathPanel->text();
    BOOL errorCode = pt_dump_packets(cmdlineInput.toStdWString().c_str());

    if (errorCode != ERROR_SUCCESS)
        ui.statusBar->showMessage("ERROR! Bad binary trace");
    else
        ui.statusBar->showMessage("Done");

    ui.labelTitle->setText(QApplication::translate("PtExploitDetectorGUIClass", "PTEXPLOITDETECTOR", nullptr));

    ui.filePathPanel->setReadOnly(false);
}